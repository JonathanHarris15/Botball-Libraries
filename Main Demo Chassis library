int bias;
void drive (int speed, int distance){
    
    float theta = 0;
    //float start_time = 0;
    //float end_time = 0;
    float error = 0;
    float target = 0;
    cmpc(0);
    cmpc(1);
    while((abs(gmpc(0)) + abs(gmpc(1)))/2 < distance * 77){
     
        //start_time = seconds();
        
        mav(0,speed + error * 0.1);
        mav(1,speed - error * 0.1);
        msleep(15);
        
        //end_time = seconds() - start_time;
        theta = theta + (gyro_z() - bias);
        error = (target - (theta));
        
        
    }
    mav(0,0);
    mav(1,0);
    msleep(20);
    
}

void calculate_bias(int loops){
    int i;
    int bias_mass = 0;
    mav(0,0);
    mav(1,0);
    msleep(100);
    for(i = 0; i < loops; i++){
        bias_mass = bias_mass + gyro_z();
        mav(0,0);
        mav(1,0);
        msleep(5);
    }
    bias = bias_mass / loops;
}
    

void right(int speed, int target){
    
    float theta = 0;
    //float start_time = 0;
    //float end_time = 0;
    while(theta > -target){
        msleep(15);
     
        //start_time = seconds();
        
        mav(0,-speed);
        mav(1,speed);
        msleep(10);
        
        //end_time = seconds() - start_time;
        theta = theta + ((gyro_z() - bias) * 0.03);
        printf("theta %f\n",theta);
        
    }
    mav(0,0); 
    mav(1,0);
    msleep(20);
    
}

void left(int speed, int target){
    
    float theta = 0;
    //float start_time = 0;
    //float end_time = 0;
    while(theta < target){
        msleep(15);
     
        //start_time = seconds();
        
        mav(0,speed);
        mav(1,-speed);
        msleep(10);
        
        //end_time = seconds() - start_time;
        theta = theta + ((gyro_z() - bias)  * 0.03);
        printf("theta %f\n",theta);
        
    }
    mav(0,0);
    mav(1,0);
    msleep(20);
    
}
//servo function by Jacob of Noble High School (written on August 8,2019)
void servo(int port, int position, int speed){   
    
    int current = get_servo_position(port);

    if(position > 2047){

        position = 2047;

    } 
    if(position < 0){

        position = 0;

    }   

    while(current <= position-speed || current >= position+speed){ 

        if(current < position){

            current += speed;
           
        }
        if(current > position){

            current -= speed;

        }
        set_servo_position(port, current);
        msleep(2);
    }

    set_servo_position(port,position);
    
} 
void line_follow(int port, int speed , int distance){
    
    int grey_value=2000;
    
    
    int right_wheel = 0;
    int left_wheel = 1;
    int speed_change;
    cmpc(0);
    int error = 0;
	while(gmpc(0) < distance * 77){
 		error = grey_value-analog(port);
    	speed_change= error*0.2;
 		mav(right_wheel ,speed - speed_change);
 		mav(left_wheel ,speed + speed_change);   
	}
    mav(0, 0);
    mav(1, 0);
    msleep(100);
} 

void line_follow2(int port, int speed , int distance){
    
    int grey_value=3100;
    
    
    int right_wheel = 0;
    int left_wheel = 1;
    int speed_change;
    cmpc(0);
    int error = 0;
	while(gmpc(0) > -distance * 77){
 		error = grey_value-analog(port);
    	speed_change= error*0.8;
 		mav(right_wheel ,speed + speed_change);
 		mav(left_wheel ,speed - speed_change);   
	}
    mav(0, 0);
    mav(1, 0);
    msleep(100);
} 

